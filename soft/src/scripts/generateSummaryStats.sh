#!/bin/bash

module load mugqic/python/2.7.14

# little fix to add sortByRef.pl on beluga to $PATH
if [[ $(echo $PATH|grep -c /lustre03/project/6001220/COMMON/soft/src/pipeline_MIPs.svn/soft/bin) -eq 0 ]]; then PATH=/lustre03/project/6001220/COMMON/soft/src/pipeline_MIPs.svn/soft/bin:$PATH; fi

# NOTE: this script will only work if primary mip pipeline analysis is complete

unset LONGARGS LONGSWITCHES SHORTARGS SHORTSWITCHES
unset BED_FILE MIP_STATS_FILE_LIST RUN_NAME PIPELINE_MODE MIP_PROJECT MIP_BATCH MIP_SUBBATCH
unset PIPELINE_HOME DO_REFSEQ DO_BED DO_BYMIP DO_BYGENE DO_BYEXON DEBUG_MODE RM_BED RM_BYMIP

#define function to handle error messages
Usage() {
        echo
        echo -e "Usage:\t$0 [arguments]"
        echo -e "\tmandatory arguments:\n" \
          "\t\t-p  (--pipeline_mode) = run this script in pipeline mode (will use pre-determined sample lists and bed files)\n" \
          "\t\t === AND ===\n" \
          "\t\t\t--mip_project  = name of MIP project (e.g. PD, ALS_Germinal)\n" \
          "\t\t\t--mip_batch    = name of MIP batch (e.g. PD_MIP55, ALS_MIP59)\n" \
          "\t\t\t--mip_subbatch = name of MIP sub-batch (e.g. PD_MIP55, ALS1234_GRP_MIP59)\n" \
          "\t\t === OR ===\n" \
          "\t\t-b (--bed_file)            = /path/to/bed file defining the MIPs to be characterized (4 mandatory columns: chrom, start, stop, mip; mip names must match those in --mip_stats_file_list\n" \
          "\t\t-l (--mip_stats_file_list) = /path/to/list of all by-sample mip-by-mip_counts files (generated by standard MIP pipeline)"
        echo -e "\toptional arguments:\n " \
          "\t\t-h  (--help) = get the program options and exit\n" \
          "\t\t-r (--run_name) = prefix for output files (default will use --mip_subbatch or --bed_file)\n" \
          "\t\t--do_refseq     = perform analysis step: makeRefSeqBedFiles (omitted by default)\n" \
          "\t\t--do_bed        = perform analysis step: makeExtendedBedFiles (included by default)\n" \
          "\t\t--do_byrefseq   = perform analysis step: makeByRefSeqCoverageFile (included by default)\n" \
          "\t\t--debug_mode    = launch this script in debug mode (will use existing intermediate files (expert; use with caution)\n" \
          "\t\t--pipeline_home = override default pipeline_home directory (expert; use with caution)"
        echo
}

# ===============================================
# PARSING ARGUMENTS
# ===============================================
# options may be followed by one colon to indicate they have a required argument
LONGARGS=(mip_project mip_batch mip_subbatch bed_file mip_stats_file_list pipeline_home run_name)
LONGSWITCHES=(help pipeline_mode do_refseq do_bed do_bymip do_byrefseq debug_mode)
SHORTARGS=(b l r)
SHORTSWITCHES=(h p)
if ! options=$(getopt --name $(basename $0) --alternative --unquoted --options $(printf "%s:" ${SHORTARGS[@]})$(printf "%s" ${SHORTSWITCHES[@]}) --longoptions $(printf "%s:," ${LONGARGS[@]})$(printf "%s," ${LONGSWITCHES[@]}|sed 's/,$//g') -- "$@")

then
    # something went wrong, getopt will put out an error message for us
    echo "Error processing options."
    exit 42
fi

#process options and and pass arguments to script variables (where applicable)
set -- $options
while [ $# -gt 0 ]
#echo -e "$1 $2"
do
    case $1 in
    -h| --help) Usage; exit 0;;
    # for options with required arguments, an additional shift is required
    -b| --bed_file            ) BED_FILE="$2" ; shift ;;
    -l| --mip_stats_file_list ) MIP_STATS_FILE_LIST="$2" ; shift ;;
    -r| --run_name            ) RUN_NAME="$2" ; shift ;;
    -p| --pipeline_mode       ) PIPELINE_MODE=1 ;;
    --mip_project   ) MIP_PROJECT="$2" ; shift ;;
    --mip_batch     ) MIP_BATCH="$2" ; shift ;;
    --mip_subbatch  ) MIP_SUBBATCH="$2" ; shift ;;
    --pipeline_home ) PIPELINE_HOME="$2" ; shift ;;
    --do_refseq     ) DO_REFSEQ=1 ;;
    --do_bed        ) DO_BED=1 ;;
    --do_bymip      ) DO_BYMIP=1 ;;
    --do_byrefseq   ) DO_BYREFSEQ=1 ;;
    --debug_mode    ) DEBUG_MODE=1 ;;
    (--) shift; break ;;
    (-*) echo "$0: ERROR - unrecognized option $1" 1>&2; exit 42 ;;
    (*) break ;;
    esac
    shift
done

#check for missing variables and nonsensical combinations
if [[ $PIPELINE_MODE -eq 1 && (-z $MIP_PROJECT || -z $MIP_BATCH || -z $MIP_SUBBATCH) ]]; then 
  echo "ERROR: if running in pipeline_mode you MUST specify --mip_project --mip_batch and --mip_subbatch";
  failure=1; 
fi
if [[ -z $PIPELINE_MODE && (! -s $BED_FILE || ! -s $MIP_STATS_FILE_LIST) ]]; then 
  echo "ERROR: if not running in pipeline_mode you MUST specify a valid --bed_file and --mip_stats_file_list";
  failure=1; 
fi
if [[ ($DO_BYMIP -eq 1 || $DO_BYREFSEQ -eq 1) && (! -s $MIP_STATS_FILE_LIST && $PIPELINE_MODE -ne 1) ]]; then 
  echo "ERROR: by_mip and by_refseq analyses require --pipeline_mode OR a valid --mip_stats_file_list";
  failure=1;
fi
if [[ $failure -eq 1 ]]; then echo "ERRORS FOUND; EXITING"; exit 42; fi

if [[ $PIPELINE_MODE -eq 1 && -s $MIP_STATS_FILE_LIST ]]; then 
  echo "WARNING: --pipeline_mode overrides --mip_stats_file_list; will use all samples for pipeline batch $MIP_PROJECT:$MIP_BATCH:$MIP_SUBBATCH";
fi
if [[ -z $RUN_NAME ]]; then 
  if [[ $PIPELINE_MODE -eq 1 ]]; then
    RUN_NAME=$MIP_SUBBATCH;
  else
    RUN_NAME=$(basename $BED_FILE|sed 's/.bed$//g');
  fi
  echo "WARNING: --run_name not specified; using default value $RUN_NAME";
fi

#set script constants
RES=~/pipeline_results
GENE_DIR=~/soft/src/pipeline_MIPs.svn/data/targets
GENE_LIST=$GENE_DIR/RefSeq.Genes.v37.refGene
if [[ $DO_REFSEQ -eq 1 ]]; then GENE_DIR=.; fi
refseq_genes=$GENE_DIR/refseq.genes.bed
refseq_exons=$GENE_DIR/refseq.exons.bed
refFlat_CDS=$GENE_DIR/refFlat.CDS
refFlat_UTR3=$GENE_DIR/refFlat.UTR3
refFlat_UTR5=$GENE_DIR/refFlat.UTR5
bedops=~/soft/packages/bedops-2.4.2

# create helper functions
BOP_SORT() { $bedops/sort-bed $1; }
list() { echo {$(echo $@|tr ' ' ',')}; }
make_header() { printf "%s\t" $@|sed 's/\t$/\n/g'; }

#set dependent variables
PIPELINE_HOME=${PIPELINE_HOME:-~/soft/src/pipeline_MIPs.svn}
if [[ $PIPELINE_MODE -eq 1 ]]; then . $PIPELINE_HOME/data/templates/link.runs.to.accessory_files.sh; fi
BED_FILE=${BED_FILE:-${BED[$MIP_SUBBATCH]}}
if [[ $PIPELINE_MODE -eq 1 ]]; then MIP_STATS_FILES=($(eval ls -1 $RES/mip/$MIP_PROJECT/$MIP_BATCH/$MIP_SUBBATCH/$(list $(cat ${LIST[$MIP_SUBBATCH]}))/I*/G*/STATS/*counts)); else MIP_STATS_FILES=($(cat $MIP_STATS_FILE_LIST)); fi

# create functions for the various analysis steps
makeRefSeqBedFiles() {
# redundant; I ran it once and put the files in $GENE_DIR (see $refseq_genes and $refseq_exons above)
echo running $FUNCNAME
cut -f3,5,6,13 $GENE_LIST|grep -v txStart|sort -k2n|sortByRef.pl - /home/spiegelm/references/gatk.ref.dict |bedtools merge -i - -c 4 -o distinct > $refseq_genes
awk 'BEGIN{FS=OFS="\t"}{split($10,a,","); split($11,b,","); for (i=1; i<length(a); i++) print $3,a[i],b[i],$13}' $GENE_LIST|grep -v txStart|sort -k2n|sortByRef.pl - /home/spiegelm/references/gatk.ref.dict |bedtools merge -i - -c 4 -o distinct > $refseq_exons
}

makeExtendedBedFiles() {
# make extended bed files (with gene names and exon types)
echo running $FUNCNAME
$bedops/bedmap --echo --echo-map <(BOP_SORT $BED_FILE) <(BOP_SORT $refseq_exons) |awk 'BEGIN{FS="|";OFS="\t"}{gene=""; delete genes; split($2,a,";"); for (i in a) gsub(/.*\t/,"",a[i]); for (i in a) genes[a[i]]=1; for (i in genes) gene=i","; gsub(/,$/,"",gene); print $1,gene}'|sort -k4n > $RUN_NAME.tmp.bed
cat <(awk 'NF==5' $RUN_NAME.tmp.bed) <($bedops/bedmap --echo --echo-map <(awk 'NF==4' $RUN_NAME.tmp.bed|BOP_SORT -) <(BOP_SORT $refseq_genes) |awk 'BEGIN{FS="|";OFS="\t"}{gene=""; delete genes; split($2,a,";"); for (i in a) gsub(/.*\t/,"",a[i]); for (i in a) genes[a[i]]=1; for (i in genes) gene=i","; gsub(/,$/,"",gene); print $1,gene}')|sort -k4n|sed 's/\t\t/\t/g' > $RUN_NAME.extended.bed
$bedops/bedmap --echo --count <(BOP_SORT $RUN_NAME.extended.bed) <(BOP_SORT $refFlat_CDS)|awk 'BEGIN{FS="|";OFS="\t"}{if ($2>0) print $1,"CDS"}' > $RUN_NAME.extended.bed.CDS
$bedops/bedmap --echo --count <($bedops/bedmap --fraction-both 1 --echo --count <(BOP_SORT $RUN_NAME.extended.bed) <(BOP_SORT $RUN_NAME.extended.bed.CDS)|awk -F"|" '{if ($NF==0) print $1}'|BOP_SORT -) <(BOP_SORT $refFlat_UTR5)|awk 'BEGIN{FS="|";OFS="\t"}{if ($2>0) print $1,"UTR5"}' > $RUN_NAME.extended.bed.UTR5
$bedops/bedmap --echo --count <($bedops/bedmap --fraction-both 1 --echo --count <(BOP_SORT $RUN_NAME.extended.bed) <(cat $RUN_NAME.extended.bed.{CDS,UTR5}|BOP_SORT -)|awk -F"|" '{if ($NF==0) print $1}'|BOP_SORT -) <(BOP_SORT $refFlat_UTR3)|awk 'BEGIN{FS="|";OFS="\t"}{if ($2>0) print $1,"UTR3"}' > $RUN_NAME.extended.bed.UTR3
cat <(make_header chrom start end mip gene exon_type) \
<(cat $RUN_NAME.extended.bed.{CDS,UTR{3,5}} <($bedops/bedmap --fraction-both 1 --echo --count <(BOP_SORT $RUN_NAME.extended.bed) <(cat $RUN_NAME.extended.bed.{CDS,UTR{3,5}}|BOP_SORT -)|awk 'BEGIN{FS="|";OFS="\t"}{if ($NF==0) {split($1,a,"\t"); if (length(a)==5) {if (a[5]=="") {gsub(/\t$/,"",$1); extra="no_gene\tno_exon"} else {extra="no_exon"}} else {print $1; next}; print $1,extra}}')|sort -k2n|sortByRef.pl - /home/spiegelm/references/gatk.ref.dict) > $RUN_NAME.tmp.bed
if [[ $(grep -c , $RUN_NAME.tmp.bed) -gt 0 ]]; then eval $(echo sed $(while read old new; do printf " -e 's/%s/%s/g' " $old $new; done < <(awk 'BEGIN{FS=OFS="\t"}{a[$5]++}END{for (x in a) if (x~/,/) {split(x,b,","); for (y in b) if (b[y] in a) print x,b[y]}}' $RUN_NAME.tmp.bed)) $RUN_NAME.tmp.bed -i); fi
if [[ $? -eq 0 ]]; then mv $RUN_NAME.tmp.bed $RUN_NAME.extended.bed && rm $RUN_NAME.extended.bed.{CDS,UTR{3,5}}; fi
}

makeByMipCoverageFile() {
# make by-mip coverage file: average, 20x, 50x, 100x
echo running $FUNCNAME
cat <(make_header chrom start end mip gene exon_type av_cov %20x %50x %100x) \
<(while read mip av x20 x50 x100; do hit=$(awk -v mip=$mip '$4==mip' <(tail -n +2 $RUN_NAME.extended.bed)); if [[ -n $hit ]]; then echo -e "$hit\t$av\t$x20\t$x50\t$x100"; fi; done < <(awk -v denom=${#MIP_STATS_FILES[@]} '{av_num[$1]+=$2; if ($2>=20) x20_num[$1]++; if ($2>50) x50_num[$1]++; if ($2>100) x100_num[$1]++}END{for (i in av_num) print i,av_num[i]/denom,x20_num[i]/denom,x50_num[i]/denom,x100_num[i]/denom}' ${MIP_STATS_FILES[@]}|sort -n)) > $RUN_NAME.by_mip.coverage_data
#DAN: tmp fix for ziv to check CDS only stats
#cat <(make_header chrom start end mip gene exon_type av_cov %20x %50x %100x) \
#<(while read mip av x20 x50 x100; do hit=$(awk -v mip=$mip '$4==mip' <(tail -n +2 $RUN_NAME.extended.bed)); if [[ -n $hit ]]; then echo -e "$hit\t$av\t$x20\t$x50\t$x100"; fi; done < <(awk -v denom=${#MIP_STATS_FILES[@]} '{av_num[$1]+=$2; if ($2>=20) x20_num[$1]++; if ($2>50) x50_num[$1]++; if ($2>100) x100_num[$1]++}END{for (i in av_num) print i,av_num[i]/denom,x20_num[i]/denom,x50_num[i]/denom,x100_num[i]/denom}' ${MIP_STATS_FILES[@]}|sort -n))|awk 'NR==1||$0~/CDS/' > $RUN_NAME.by_mip.coverage_data
}

makeByRefSeqCoverageFile() {
# make by_gene and by_exon coverage files: average, 20x, 50x, 100x
echo running $FUNCNAME
python $(dirname $0)/generateByGeneByExonStats.py <(bedtools intersect -a $refseq_exons -b <(tail -n +2 $RUN_NAME.by_mip.coverage_data) -wao|grep -vP "\s0$") $RUN_NAME
cat <(head -1 $RUN_NAME.by_exon.coverage_data) <(sort -k2n $RUN_NAME.by_exon.coverage_data|sortByRef.pl - /home/spiegelm/references/gatk.ref.dict) > tmp; mv tmp $RUN_NAME.by_exon.coverage_data
}

# ===============================================
# MAIN
# ===============================================
if [[ ($DO_BYREFSEQ -eq 1 || $DO_BYMIP -eq 1) && -z $DO_BED && -z $DEBUG_MODE ]]; then makeExtendedBedFiles; RM_BED=1; fi
if [[ $DO_BYREFSEQ && -z $DO_BYMIP && -z $DEBUG_MODE ]]; then makeByMipCoverageFile; RM_BYMIP=1; fi
if [[ -z $DO_REFSEQ && -z $DO_BED && -z $DO_BYMIP && -z $DO_BYREFSEQ ]]; then DO_BED=1; DO_BYMIP=1; DO_BYREFSEQ=1; fi

[[ $DO_REFSEQ ]] && makeRefSeqBedFiles
[[ $DO_BED ]] && makeExtendedBedFiles
[[ $DO_BYMIP ]] && makeByMipCoverageFile
[[ $DO_BYREFSEQ ]] && makeByRefSeqCoverageFile
[[ $RM_BED ]] && rm $RUN_NAME.extended.bed
[[ $RM_BYMIP ]] && rm $RUN_NAME.by_mip.coverage_data
